
<font size="5">[返回目录](../../目录.md)</font>
<font size="5">[返回算法笔记](../../算法.md/##6动态规划)</font>
____
# 1.动态规划

## 1.1 单维动态规划


## 1.2 多维动态规划
### 72. 编辑距离([原题](https://leetcode.cn/problems/edit-distance/description/))[多维动态规划]
困难

给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。

你可以对一个单词进行如下三种操作：

插入一个字符
删除一个字符
替换一个字符
 

    示例 1：

    输入：word1 = "horse", word2 = "ros"
    输出：3
    解释：
    horse -> rorse (将 'h' 替换为 'r')
    rorse -> rose (删除 'r')
    rose -> ros (删除 'e')

>

    示例 2：

    输入：word1 = "intention", word2 = "execution"
    输出：5
    解释：
    intention -> inention (删除 't')
    inention -> enention (将 'i' 替换为 'e')
    enention -> exention (将 'n' 替换为 'x')
    exention -> exection (将 'n' 替换为 'c')
    exection -> execution (插入 'u')
 

提示：

* `0 <= word1.length, word2.length <= 500`
* `word1 和 word2 由小写英文字母组成`

##### 解法
```python
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        n1 = len(word1)
        n2 = len(word2)
        dp = [[0] * (n2 + 1) for _ in range(n1 + 1)]
        # 第一行
        for j in range(1, n2 + 1):
            dp[0][j] = dp[0][j-1] + 1
        # 第一列
        for i in range(1, n1 + 1):
            dp[i][0] = dp[i-1][0] + 1
        for i in range(1, n1 + 1):
            for j in range(1, n2 + 1):
                if word1[i-1] == word2[j-1]:
                    dp[i][j] = dp[i-1][j-1]
                else:
                    dp[i][j] = min(dp[i][j-1], dp[i-1][j], dp[i-1][j-1] ) + 1
        #print(dp)      
        return dp[-1][-1]
```
![Alt text](../算法/62_1.png)
1. 使用i作为x轴，j作为y轴建立二维矩阵
2. 空出一行的余量用于启动
3. 三种操作的前一状态分别对应 删除 (dp[i-1][j] 插入dp[i][j-1] 替换 dp[i-1][j-1])
4. 对角线保存的就是完成当前字符操作的最少步数

```python
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        import functools
        @functools.lru_cache(None)
        def helper(i, j):
            if i == len(word1) or j == len(word2):
                return len(word1) - i + len(word2) - j
            if word1[i] == word2[j]:
                return helper(i + 1, j + 1)
            else:
                inserted = helper(i, j + 1)
                deleted = helper(i + 1, j)
                replaced = helper(i + 1, j + 1)
                return min(inserted, deleted, replaced) + 1
        return helper(0, 0)
作者：powcai
链接：https://leetcode.cn/problems/edit-distance/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```
## 1.3 记忆化搜索
### 823. 带因子的二叉树([原题](https://leetcode.cn/problems/binary-trees-with-factors/description/))

中等

给出一个含有不重复整数元素的数组 arr ，每个整数 arr[i] 均大于 1。

用这些整数来构建二叉树，每个整数可以使用任意次数。其中：每个非叶结点的值应等于它的两个子结点的值的乘积。

满足条件的二叉树一共有多少个？答案可能很大，返回 对 109 + 7 取余 的结果。

 

    示例 1:

    输入: arr = [2, 4]
    输出: 3
    解释: 可以得到这些二叉树: [2], [4], [4, 2, 2]
>
    示例 2:

    输入: arr = [2, 4, 5, 10]
    输出: 7
    解释: 可以得到这些二叉树: [2], [4], [5], [10], [4, 2, 2], [10, 2, 5], [10, 5, 2].
    

提示：

* `1 <= arr.length <= 1000`
* `2 <= arr[i] <= 109`
* `arr 中的所有值 互不相同`

#### 本人解法
##### 初次尝试
```python
class Solution:
    def numFactoredBinaryTrees(self, arr: List[int]) -> int:
        arr.sort()
        n = len(arr)
        e = arr[-1]
        a= {}
        ans = 0 
        mod = 10**9+7
        for i in arr :
            a[i] = 1
            ans +=1 
        
        for i in range(n) :
            for j in range(n):
                num = arr[i] * arr[j]
                if num > e :
                    break
                elif num in arr :
                    a[num] += a[arr[i]] * a[arr[j]]

        for i in range(n) :
            for j in range(n):
                num = arr[i] * arr[j]
                if num > e :
                    break
                elif num in arr :
                    ans += a[arr[i]] * a[arr[j]] 
                    ans %= mod 
        return ans 
```
##### 分析
先将数组进行排序肯定是不会出现问题的。考虑到所给出的数组长度最长也只有1000，完全支持**O(n^2^)** 的计算。所有先将每种数字可能的情况全都通过一次二重循环保存至哈希表a中。然后再通过一次二重循环获取具体的解法。

##### 错误分析
在用例`[45,42,2,18,23,1170,12,41,40,9,47,24,33,28,10,32,29,17,46,11,759,37,6,26,21,49,31,14,19,8,13,7,27,22,3,36,34,38,39,30,43,15,4,16,35,25,20,44,5,48]`中出现了错误,对输出值进行分析
```python
#当num == 12 时输出arr[i],arr[j]与a[arr[i]] * a[arr[j]]
2 6
2
3 4
2
4 3
2
6 2
3
```
发现`同种组合在前后的值不同`，这与我们的要求不符合。错误出现在第一次循环处。
普通的遍历无法避免这种情况的发生，需要使用以数值为中心进行遍历。即**将一次双重循环完全留给单数值进行操作**。本质上是**使用一次三重循环**
优化：
1. 由于仅对单数值进行操作，故遍历范围仅需在(0,t)之间，其中t为当前数值的下标。
2. 可以在循环的末尾直接添加ans值，节省一次双重循环  

风险：
1. 三重循环时间复杂度为**O(n^3^)** 极易出现超时
   
##### 第二次提交
```python   
class Solution:
    def numFactoredBinaryTrees(self, arr: List[int]) -> int:
        arr.sort()
        n = len(arr)
        e = arr[-1]
        a= {}
        ans = 0 
        mod = 10**9+7
        for index,t in enumerate(arr) :
            a[t] = 1
            for i in range(index) :
                for j in range(index):
                    num = arr[i] * arr[j]
                    if num == t:
                        a[num] += a[arr[i]] * a[arr[j]]
            ans += a[t]
            ans %= mod 
          
        return ans 
```
果不其然，超出了时间限制。看来仅用哈希表是不得行了。
分析一下发现存在大量的重复运算，那是不是可以试下记忆化搜素？
记不出来一点。准备开摆了。
#### 他人解法
```python
class Solution:
    def numFactoredBinaryTrees(self, arr: List[int]) -> int:
        arr.sort()
        idx = {x: i for i, x in enumerate(arr)}
        @cache  # 缓存装饰器，避免重复计算 dfs 的结果
        def dfs(i: int) -> int:
            res = 1
            val = arr[i]
            for j in range(i):  # val 的因子一定比 val 小
                x = arr[j]
                if val % x == 0 and val // x in idx:  # 另一个因子 val/x 必须在 arr 中
                    res += dfs(j) * dfs(idx[val // x])
            return res
        return sum(dfs(i) for i in range(len(arr))) % (10 ** 9 + 7)

作者：灵茶山艾府
链接：https://leetcode.cn/problems/binary-trees-with-factors/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```
可见至少思路是没有问题的，已经胜利了一大半了。
#### 总结
1. 如果出现遍历导致前后运算互相影响的情况可以试试递归
2. 如果递归或者循环中出现大量重复运算可以试着进行记忆化搜索


###
