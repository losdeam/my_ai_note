
<font size="5">[返回目录](../../目录.md)</font>
<font size="5">[返回算法笔记](../../算法.md/##6动态规划)</font>
____
# 1.动态规划

## 1.1 单维动态规划


## 1.2 多维动态规划

## 1.3 记忆化搜索
### 823. 带因子的二叉树([原题](https://leetcode.cn/problems/binary-trees-with-factors/description/))

中等

给出一个含有不重复整数元素的数组 arr ，每个整数 arr[i] 均大于 1。

用这些整数来构建二叉树，每个整数可以使用任意次数。其中：每个非叶结点的值应等于它的两个子结点的值的乘积。

满足条件的二叉树一共有多少个？答案可能很大，返回 对 109 + 7 取余 的结果。

 

    示例 1:

    输入: arr = [2, 4]
    输出: 3
    解释: 可以得到这些二叉树: [2], [4], [4, 2, 2]
>
    示例 2:

    输入: arr = [2, 4, 5, 10]
    输出: 7
    解释: 可以得到这些二叉树: [2], [4], [5], [10], [4, 2, 2], [10, 2, 5], [10, 5, 2].
    

提示：

* `1 <= arr.length <= 1000`
* `2 <= arr[i] <= 109`
* `arr 中的所有值 互不相同`

#### 本人解法
##### 初次尝试
```python
class Solution:
    def numFactoredBinaryTrees(self, arr: List[int]) -> int:
        arr.sort()
        n = len(arr)
        e = arr[-1]
        a= {}
        ans = 0 
        mod = 10**9+7
        for i in arr :
            a[i] = 1
            ans +=1 
        
        for i in range(n) :
            for j in range(n):
                num = arr[i] * arr[j]
                if num > e :
                    break
                elif num in arr :
                    a[num] += a[arr[i]] * a[arr[j]]

        for i in range(n) :
            for j in range(n):
                num = arr[i] * arr[j]
                if num > e :
                    break
                elif num in arr :
                    ans += a[arr[i]] * a[arr[j]] 
                    ans %= mod 
        return ans 
```
##### 分析
先将数组进行排序肯定是不会出现问题的。考虑到所给出的数组长度最长也只有1000，完全支持**O(n^2^)** 的计算。所有先将每种数字可能的情况全都通过一次二重循环保存至哈希表a中。然后再通过一次二重循环获取具体的解法。

##### 错误分析
在用例`[45,42,2,18,23,1170,12,41,40,9,47,24,33,28,10,32,29,17,46,11,759,37,6,26,21,49,31,14,19,8,13,7,27,22,3,36,34,38,39,30,43,15,4,16,35,25,20,44,5,48]`中出现了错误,对输出值进行分析
```python
#当num == 12 时输出arr[i],arr[j]与a[arr[i]] * a[arr[j]]
2 6
2
3 4
2
4 3
2
6 2
3
```
发现`同种组合在前后的值不同`，这与我们的要求不符合。错误出现在第一次循环处。
普通的遍历无法避免这种情况的发生，需要使用以数值为中心进行遍历。即**将一次双重循环完全留给单数值进行操作**。本质上是**使用一次三重循环**
优化：
1. 由于仅对单数值进行操作，故遍历范围仅需在(0,t)之间，其中t为当前数值的下标。
2. 可以在循环的末尾直接添加ans值，节省一次双重循环  

风险：
1. 三重循环时间复杂度为**O(n^3^)** 极易出现超时
   
##### 第二次提交
```python   
class Solution:
    def numFactoredBinaryTrees(self, arr: List[int]) -> int:
        arr.sort()
        n = len(arr)
        e = arr[-1]
        a= {}
        ans = 0 
        mod = 10**9+7
        for index,t in enumerate(arr) :
            a[t] = 1
            for i in range(index) :
                for j in range(index):
                    num = arr[i] * arr[j]
                    if num == t:
                        a[num] += a[arr[i]] * a[arr[j]]
            ans += a[t]
            ans %= mod 
          
        return ans 
```
果不其然，超出了时间限制。看来仅用哈希表是不得行了。
分析一下发现存在大量的重复运算，那是不是可以试下记忆化搜素？
记不出来一点。准备开摆了。
#### 他人解法
```python
class Solution:
    def numFactoredBinaryTrees(self, arr: List[int]) -> int:
        arr.sort()
        idx = {x: i for i, x in enumerate(arr)}
        @cache  # 缓存装饰器，避免重复计算 dfs 的结果
        def dfs(i: int) -> int:
            res = 1
            val = arr[i]
            for j in range(i):  # val 的因子一定比 val 小
                x = arr[j]
                if val % x == 0 and val // x in idx:  # 另一个因子 val/x 必须在 arr 中
                    res += dfs(j) * dfs(idx[val // x])
            return res
        return sum(dfs(i) for i in range(len(arr))) % (10 ** 9 + 7)

作者：灵茶山艾府
链接：https://leetcode.cn/problems/binary-trees-with-factors/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```
可见至少思路是没有问题的，已经胜利了一大半了。
#### 总结
1. 如果出现遍历导致前后运算互相影响的情况可以试试递归
2. 如果递归或者循环中出现大量重复运算可以试着进行记忆化搜索