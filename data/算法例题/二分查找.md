
<font size="5">[返回目录](../../目录.md)</font>
<font size="5">[返回算法笔记](../../算法.md/##7.二分查找)</font>
____
# 1.二分查找

## 1.1 最小值查询
### 2594. 修车的最少时间([原题](https://leetcode.cn/problems/minimum-time-to-repair-cars/description/))

中等

给你一个整数数组 ranks ，表示一些机械工的 能力值 。ranks i 是第 i 位机械工的能力值。能力值为 r 的机械工可以在 r * n2 分钟内修好 n 辆车。

同时给你一个整数 cars ，表示总共需要修理的汽车数目。

请你返回修理所有汽车 最少 需要多少时间。

注意：所有机械工可以同时修理汽车。

 

    示例 1：

    输入：ranks = [4,2,3,1], cars = 10
    输出：16
    解释：
    - 第一位机械工修 2 辆车，需要 4 * 2 * 2 = 16 分钟。
    - 第二位机械工修 2 辆车，需要 2 * 2 * 2 = 8 分钟。
    - 第三位机械工修 2 辆车，需要 3 * 2 * 2 = 12 分钟。
    - 第四位机械工修 4 辆车，需要 1 * 4 * 4 = 16 分钟。
    16 分钟是修理完所有车需要的最少时间。
>

    示例 2：

    输入：ranks = [5,1,8], cars = 6
    输出：16
    解释：
    - 第一位机械工修 1 辆车，需要 5 * 1 * 1 = 5 分钟。
    - 第二位机械工修 4 辆车，需要 1 * 4 * 4 = 16 分钟。
    - 第三位机械工修 1 辆车，需要 8 * 1 * 1 = 8 分钟。
    16 分钟时修理完所有车需要的最少时间。
 

提示：

* `1 <= ranks.length <= 105`
* `1 <= ranks[i] <= 100`
* `1 <= cars <= 106`

#### 本人解法
```python
class Solution:
    def repairCars(self, ranks: List[int], cars: int) -> int:
        def get_time (time ):
            ans  = 0 
            for i in ranks:
                ans  += int (sqrt(time/i))
            return ans 
        
        l,r = 0 , max(ranks)*cars**2
        while l < r :
            mid = (l+r) // 2
            num = get_time(mid)
            if num < cars:
                l = mid +1
            else:
                r = mid 
        return r 
```

                
### 2560. 打家劫舍 IV([原题](https://leetcode.cn/problems/house-robber-iv/description/))

中等

沿街有一排连续的房屋。每间房屋内都藏有一定的现金。现在有一位小偷计划从这些房屋中窃取现金。

由于相邻的房屋装有相互连通的防盗系统，所以小偷 不会窃取相邻的房屋 。

小偷的 窃取能力 定义为他在窃取过程中能从单间房屋中窃取的 最大金额 。

给你一个整数数组 nums 表示每间房屋存放的现金金额。形式上，从左起第 i 间房屋中放有 nums[i] 美元。

另给你一个整数 k ，表示窃贼将会窃取的 最少 房屋数。小偷总能窃取至少 k 间房屋。

返回小偷的 最小 窃取能力。

 

> 示例 1：
> 
> 输入：nums = [2,3,5,9], k = 2
> 输出：5
> 解释：
> 小偷窃取至少 2 间房屋，共有 3 种方式：
> - 窃取下标 0 和 2 处的房屋，窃取能力为 max(nums[0], nums[2]) = 5 。
> - 窃取下标 0 和 3 处的房屋，窃取能力为 max(nums[0], nums[3]) = 9 。
> - 窃取下标 1 和 3 处的房屋，窃取能力为 max(nums[1], nums[3]) = 9 。
> 因此，返回 min(5, 9, 9) = 5 。
 
> 示例 2：
> 
> 输入：nums = [2,7,9,3,1], k = 2
> 输出：2
> 解释：共有 7 种窃取方式。窃取能力最小的情况所对应的方式是窃取下标 0 和 4 处的房> 屋。返回 max(nums[0], nums[4]) = 2 。
 

提示：

- `1 <= nums.length <= 10^5`
- `1 <= nums[i] <= 10^9`
- `1 <= k <= (nums.length + 1)/2`

#### 本人解法
```python
class Solution:
    def minCapability(self, nums: List[int], k: int) -> int:
        n = len(nums)
        if n == 1 :
            return nums[0]
        l = []
        r = []
        dp = [[[],k],[[],k-1]] 
        heapq.heappush(dp[1][0],-nums[0]) 
        ans = inf 
        
        for i in range(1,n):
            if dp[0][0] and dp[0][0][-1] > dp[1][0][-1]:
               dp[1][0] = dp[0][0].copy()
               dp[1][1] = dp[0][1]
            
            if dp[0][1] == 0 :
                if dp[0][0][0] < -nums[i]:
                    heapq.heapreplace(dp[0][0],-nums[i])
            else:
                heapq.heappush(dp[0][0],-nums[i]) 
                dp[0][1]-=1 
            if dp[0][1] == 0 : 
                ans = min(ans,-dp[0][0][0])
            dp[0],dp[1] = dp[1],dp[0]
            print(dp)
        return ans
```
连着几天都是动态规划的，做惯了，脑子一下子没转过来。代码就别瞅了，是错的

#### 他人解法
```python
class Solution:
    def minCapability(self, nums: List[int], k: int) -> int:
        # solve(mx) 返回最大金额为 mx 时，最多可以偷多少间房子
        def solve(mx: int) -> int:
            f0 = f1 = 0
            for x in nums:
                if x > mx:
                    f0 = f1
                else:
                    f0, f1 = f1, max(f1, f0 + 1)
            return f1
        return bisect_left(range(max(nums)), k, key=solve)

作者：灵茶山艾府
链接：https://leetcode.cn/problems/house-robber-iv/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```
看到最大最小值就要直接想到二分查找

### 2251. 花期内花的数目([原题](https://leetcode.cn/problems/number-of-flowers-in-full-bloom/description/))

困难

给你一个下标从 0 开始的二维整数数组 flowers ，其中 flowers[i] = [starti, endi] 表示第 i 朵花的 花期 从 starti 到 endi （都 包含）。同时给你一个下标从 0 开始大小为 n 的整数数组 people ，people[i] 是第 i 个人来看花的时间。

请你返回一个大小为 n 的整数数组 answer ，其中 answer[i]是第 i 个人到达时在花期内花的 数目 。

 

> 示例 1：
> ![Alt text](2251_1.png)
> 输入：flowers = `[[1,6],[3,7],[9,12],[4,13]]`, people = [2,3,7,11]
> 输出：[1,2,2,2]
> 解释：上图展示了每朵花的花期时间，和每个人的到达时间。
> 对每个人，我们返回他们到达时在花期内花的数目。

> 示例 2：
> ![Alt text](2251_2.png)
> 输入：flowers = `[[1,10],[3,3]]`, people = [3,3,2]
> 输出：[2,2,1]
> 解释：上图展示了每朵花的花期时间，和每个人的到达时间。
> 对每个人，我们返回他们到达时在花期内花的数目。
 

提示：

> `1 <= flowers.length <= 5 * 10^4`
> `flowers[i].length == 2`
> `1 <= starti <= endi <= 10^9`
> `1 <= people.length <= 5 * 10^4`
> `1 <= people[i] <= 10^9`


#### 本人解法
```python
class Solution:
    def fullBloomFlowers(self, flowers: List[List[int]], people: List[int]) -> List[int]:
        a = dict()
        flowers.sort()

        n_flowers = len(flowers)
        n_flower_now = 0  
        now = 0 

        people = [(i,index) for index,i in enumerate(people)]
        people.sort()

        heap = [0]
        ans = [-1 for i in people]
        num = 1
        print(flowers)
        # 可以考虑使用堆的方式保存末尾
        # 以人物列表作为主要循环进行推进
        # 存在几种情况
        # 1. 人物所到的时间高于当前时间 ， 通过推进花列表来推进时间
        # 2. 人物所到的时间低于于当前时间 ， 移除堆中小于人物到达时间的花
        for time,index  in people:
            while n_flower_now < n_flowers:

                #当人来的时间在当前时间之前，不会使得花期出堆，可以直接返回
                if time < now :
                    ans[index] = num - 1 
                    break

                # 当人来的时间在当前时间之后，需要进行判断，堆中所有小于time的花均需移除，（time>=now）
                while heap and heap[0] < time :
                    heapq.heappop(heap)
                    num -=1 
                # 让花进堆
                left , right = flowers[n_flower_now]
                n_flower_now += 1 
                heapq.heappush(heap, right)
                now = left
                num +=1 

            while heap and heap[0] < time :
                heapq.heappop(heap)
                num -=1 
            if time < now :
                ans[index] = num - 1 
            else:
                ans[index] = num
            
        return ans
```
看着是不是非常的高大上？毛，二分就能做，看到答案直接傻了

#### 他人解法
与本人思路相同的差分法
```python
class Solution:
    def fullBloomFlowers(self, flowers: List[List[int]], people: List[int]) -> List[int]:
        diff = Counter()
        for start, end in flowers:
            diff[start] += 1
            diff[end + 1] -= 1
        times = sorted(diff.keys())

        j = s = 0
        for p, i in sorted(zip(people, range(len(people)))):
            while j < len(times) and times[j] <= p:
                s += diff[times[j]]  # 累加不超过 people[i] 的差分值
                j += 1
            people[i] = s  # 从而得到这个时刻花的数量
        return people

作者：灵茶山艾府
链接：https://leetcode.cn/problems/number-of-flowers-in-full-bloom/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

爆杀本人的二分法
```python
class Solution:
    def fullBloomFlowers(self, flowers: List[List[int]], people: List[int]) -> List[int]:
        starts = sorted(s for s, _ in flowers)
        ends = sorted(e for _, e in flowers)
        return [bisect_right(starts, p) - bisect_left(ends, p) for p in people]

作者：灵茶山艾府
链接：https://leetcode.cn/problems/number-of-flowers-in-full-bloom/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```