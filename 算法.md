# [笔记目录](目录.md)
# 算法部分

## 滑动窗口
&emsp; 当需要保持一个经常发生变动的数组/子串时，并对所给数据中的部分按要求进行截取时可以采用滑动窗口的形式
___
### 例题
#### [76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)

困难

给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。

 

注意：
* 对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。
  
* 如果 s 中存在这样的子串，我们保证它是唯一的答案。
 

>示例 1：
>输入：s = "ADOBECODEBANC", t = "ABC"
>输出："BANC"
>解释：最小覆盖子串 "BANC" 包含来自字符串 t 的 'A'、'B' 和 'C'。


>示例 2：
>输入：s = "a", t = "a"
>输出："a"
>解释：整个字符串 s 是最小覆盖子串。

>示例 3:
>输入: s = "a", t = "aa"
>输出: ""
>解释: t 中两个字符 'a' 均应包含在 s 的子串中，
>因此没有符合条件的子字符串，返回空字符串。
 

提示：

* m == s.length
* n == t.length
* 1 <= m, n <= 105
* s 和 t 由英文字母组成
 

进阶：你能设计一个在 o(m+n) 时间内解决此问题的算法吗？

##### 本人解法：
######   首次提交
```python
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        a = {}
        b = {}

        for i in t :
            b[i] = b.get(i,0) +1 

        def Count(a,b):
            for i in b :
                if a.get(i,0) < b[i]:
                    return True
            return False
            
        n = len(s)
        l,r = 0,0 
        ans = ""
        temp = inf
        while r < n :
            while r < n and Count(a,b):
                a[s[r]] = a.get(s[r],0) +1 
                r+=1 
            while l<r and a.get(s[l],0) > b.get(s[l],-1):
                a[s[l]] =a.get(s[l],0) -1 
                l+=1 
            if r-l < temp and not Count(a,b) :
                temp = r-l 
                ans = s[l:r]
            if r >=n :
                break
            a[s[l]] =a.get(s[l],0) -1 
            l+=1 
        return ans
```
###### 想法
分析题目，要求取字符串中的子串，可以很快的想到要使用滑动窗口。虽然很丑陋，但是还是勉强满足了要求
![Alt text](data/算法/76_1.png)
###### 他人更优解
```
def minWindow(self, s: str, t: str) -> str:
    need=collections.defaultdict(int)
    for c in t:
        need[c]+=1
    needCnt=len(t)
    i=0
    res=(0,float('inf'))
    for j,c in enumerate(s):
        if need[c]>0:
            needCnt-=1
        need[c]-=1
        if needCnt==0:       #步骤一：滑动窗口包含了所有T元素
            while True:      #步骤二：增加i，排除多余元素
                c=s[i] 
                if need[c]==0:
                    break
                need[c]+=1
                i+=1
            if j-i<res[1]-res[0]:   #记录结果
                res=(i,j)
            need[s[i]]+=1  #步骤三：i增加一个位置，寻找新的满足条件滑动窗口
            needCnt+=1
            i+=1
    return '' if res[1]>len(s) else s[res[0]:res[1]+1]    #如果res始终没被更新过，代表无满足条件的结果

作者：Mcdull
链接：https://leetcode.cn/problems/minimum-window-substring/solutions/258513/tong-su-qie-xiang-xi-de-miao-shu-hua-dong-chuang-k/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

## 链表

## 树

## 图

## 堆
&emsp; 当需要保持一个经常发生变动的列表的有序性时可以采用堆的形式
________________________________________________
### 定义
### python中的使用
&emsp; python中内置了`heapq`来方便我们构建根堆(默认只有小根堆)
#### 常用函数
> * `heappush` # 往堆中添加新值
> * `heapify` #以线性时间将一个列表转化为小根堆
> * `heappop` # 从堆中弹出并返回最小的值
_____________________________________________
### 例题

## 动态规划
### 定义
_____________________________________________
### 例题
#### [ 1289. 下降路径最小和 II](https://leetcode.cn/problems/minimum-falling-path-sum-ii/description/)
提示 困难
给你一个 n x n 整数矩阵 grid ，请你返回 非零偏移下降路径 数字和的最小值。

非零偏移下降路径 定义为：从 grid 数组中的每一行选择一个数字，且按顺序选出来的数字中，相邻数字不在原数组的同一列。

 

示例 1：

![Alt text](data/算法/1289_1.png)

输入：grid = `[[1,2,3],[4,5,6],[7,8,9]]`
输出：13
解释：
所有非零偏移下降路径包括：
[1,5,9], [1,5,7], [1,6,7], [1,6,8],
[2,4,8], [2,4,9], [2,6,7], [2,6,8],
[3,4,8], [3,4,9], [3,5,7], [3,5,9]
下降路径中数字和最小的是 [1,5,7] ，所以答案是 13 。
示例 2：

输入：grid = `[[7]]`
输出：7
 

提示：

* n == grid.length == grid[i].length
* 1 <= n <= 200
* -99 <= grid[i][j] <= 99

##### 本人解法：
######   首次提交
```python
class Solution:
    def minFallingPathSum(self, grid: List[List[int]]) -> int:
        n = len(grid)
        a = {}

        #利用递归实现动态规划
        def get(index_x,index_y):
            temp = inf
            if (index_x,index_y) in a :
                return a[(index_x,index_y)]
            else:
                if index_x+1 < n :
                    for index , i in enumerate(grid[index_x]):
                        #不在同列时,搜索最佳答案并保留结果
                        if index != index_y:
                            temp = min(temp,get(index_x+1,index)+grid[index_x][index_y])
                    a[(index_x,index_y)] = temp
                    return temp
                else:
                    a[(index_x,index_y)] = grid[index_x][index_y]
                    return a[(index_x,index_y)]
        
        return min( get(0,i) for i in range(n))
```
###### 想法
分析题目可得，下降路径中每一行都是独立的，有且只有上一行的同列不可取。可以使用递归的方式实现动态规划，并使用字典来防止重复计算。
* 时间复杂度分析:**O(n^2^)**
* 空间复杂度分析:**O(n^2^)**
原本以为200^2^还是能接受的，可是还是出现的超时

###### 分析
每一行实际上都只用到了最小和次小值(当无法取得最小值时取次大值)，可将空间复杂度压缩为**O(n)**，同时大大缩短了查找的时间

###### 第二次提交
```python
class Solution:
    def minFallingPathSum(self, grid: List[List[int]]) -> int:
        n = len(grid)
        a = {}
        if n ==1 : #由于n==1 时无法取得次大值，故需要特殊判断
            return grid[0][0]

        def get(index_x,index_y):
            temp = [inf,-1] #最大值
            temp_1 = [inf,-1]#次大值
            if index_x in a :
                return a[index_x][1] if index_y != a[index_x][0] else a[index_x][2] 
            else:
                if index_x+1 < n :
                    for index in range(n):
                        temp_2 = get(index_x+1,index)+grid[index_x][index]
                        if temp_2 < temp[0] :
                            temp_1 = temp
                            temp = (temp_2,index)
                        elif temp_2 < temp_1[0]:
                            temp_1 = (temp_2,index)
                    a[index_x] = (temp[1],temp[0],temp_1[0])
                else:
                    for index in range(n):
                        temp_2 = grid[n-1][index]
                        if temp_2 < temp[0] :
                            temp_1 = temp
                            temp = (temp_2,index)
                        elif temp_2 < temp_1[0]:
                            temp_1 = (temp_2,index)
                    a[index_x] = (temp[1],temp[0],temp_1[0])
            return a[index_x][1] if index_y != a[index_x][0] else a[index_x][2]
        return min( get(0,i) for i in range(n))
```
* 时间复杂度分析:**O(n^2^)**
* 空间复杂度分析:**O(n)**
成功通过
![Alt text](data/算法/1289_2.png)

###### 他人更优解
``` python
class Solution:
    def minFallingPathSum(self, grid: List[List[int]]) -> int:
        f = g = 0
        fp = -1
        for row in grid:
            ff = gg = inf
            ffp = -1
            for j, v in enumerate(row):
                s = (g if j == fp else f) + v
                if s < ff:
                    gg = ff
                    ff = s
                    ffp = j
                elif s < gg:
                    gg = s
            f, g, fp = ff, gg, ffp
        return f

作者：ylb
链接：https://leetcode.cn/problems/minimum-falling-path-sum-ii/solutions/2381174/python3javacgotypescript-yi-ti-yi-jie-do-sko0/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```
* 时间复杂度分析:**O(n^2^)**
* 空间复杂度分析:**O(1)**