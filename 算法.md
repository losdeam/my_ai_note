# [笔记目录](目录.md)
# 算法部分

## 滑动窗口

## 链表

## 树

## 图

## 堆
&emsp; 当需要保持一个经常发生变动的列表的有序性时可以采用堆的形式
________________________________________________
### 定义
### python中的使用
&emsp; python中内置了`heapq`来方便我们构建根堆(默认只有小根堆)
#### 常用函数
> * `heappush` # 往堆中添加新值
> * `heapify` #以线性时间将一个列表转化为小根堆
> * `heappop` # 从堆中弹出并返回最小的值
_____________________________________________
### 例题

## 动态规划
### 定义
_____________________________________________
### 例题
#### [ 1289. 下降路径最小和 II](https://leetcode.cn/problems/minimum-falling-path-sum-ii/description/)
提示 困难
给你一个 n x n 整数矩阵 grid ，请你返回 非零偏移下降路径 数字和的最小值。

非零偏移下降路径 定义为：从 grid 数组中的每一行选择一个数字，且按顺序选出来的数字中，相邻数字不在原数组的同一列。

 

示例 1：

![Alt text](data/算法/1289_1.png)

输入：grid = `[[1,2,3],[4,5,6],[7,8,9]]`
输出：13
解释：
所有非零偏移下降路径包括：
[1,5,9], [1,5,7], [1,6,7], [1,6,8],
[2,4,8], [2,4,9], [2,6,7], [2,6,8],
[3,4,8], [3,4,9], [3,5,7], [3,5,9]
下降路径中数字和最小的是 [1,5,7] ，所以答案是 13 。
示例 2：

输入：grid = `[[7]]`
输出：7
 

提示：

* n == grid.length == grid[i].length
* 1 <= n <= 200
* -99 <= grid[i][j] <= 99

##### 本人解法：
######   首次提交
```python
class Solution:
    def minFallingPathSum(self, grid: List[List[int]]) -> int:
        n = len(grid)
        a = {}

        #利用递归实现动态规划
        def get(index_x,index_y):
            temp = inf
            if (index_x,index_y) in a :
                return a[(index_x,index_y)]
            else:
                if index_x+1 < n :
                    for index , i in enumerate(grid[index_x]):
                        #不在同列时,搜索最佳答案并保留结果
                        if index != index_y:
                            temp = min(temp,get(index_x+1,index)+grid[index_x][index_y])
                    a[(index_x,index_y)] = temp
                    return temp
                else:
                    a[(index_x,index_y)] = grid[index_x][index_y]
                    return a[(index_x,index_y)]
        
        return min( get(0,i) for i in range(n))
```
###### 想法
分析题目可得，下降路径中每一行都是独立的，有且只有上一行的同列不可取。可以使用递归的方式实现动态规划，并使用字典来防止重复计算。
* 时间复杂度分析:**O(n^2^)**
* 空间复杂度分析:**O(n^2^)**
原本以为200^2^还是能接受的，可是还是出现的超时

###### 分析
每一行实际上都只用到了最小和次小值(当无法取得最小值时取次大值)，可将空间复杂度压缩为**O(n)**，同时大大缩短了查找的时间

###### 第二次提交
```python
class Solution:
    def minFallingPathSum(self, grid: List[List[int]]) -> int:
        n = len(grid)
        a = {}
        if n ==1 : #由于n==1 时无法取得次大值，故需要特殊判断
            return grid[0][0]

        def get(index_x,index_y):
            temp = [inf,-1] #最大值
            temp_1 = [inf,-1]#次大值
            if index_x in a :
                return a[index_x][1] if index_y != a[index_x][0] else a[index_x][2] 
            else:
                if index_x+1 < n :
                    for index in range(n):
                        temp_2 = get(index_x+1,index)+grid[index_x][index]
                        if temp_2 < temp[0] :
                            temp_1 = temp
                            temp = (temp_2,index)
                        elif temp_2 < temp_1[0]:
                            temp_1 = (temp_2,index)
                    a[index_x] = (temp[1],temp[0],temp_1[0])
                else:
                    for index in range(n):
                        temp_2 = grid[n-1][index]
                        if temp_2 < temp[0] :
                            temp_1 = temp
                            temp = (temp_2,index)
                        elif temp_2 < temp_1[0]:
                            temp_1 = (temp_2,index)
                    a[index_x] = (temp[1],temp[0],temp_1[0])
            return a[index_x][1] if index_y != a[index_x][0] else a[index_x][2]
        return min( get(0,i) for i in range(n))
```
* 时间复杂度分析:**O(n^2^)**
* 空间复杂度分析:**O(n)**
成功通过
![Alt text](data/算法/1289_2.png)

###### 他人更优解
``` python
class Solution:
    def minFallingPathSum(self, grid: List[List[int]]) -> int:
        f = g = 0
        fp = -1
        for row in grid:
            ff = gg = inf
            ffp = -1
            for j, v in enumerate(row):
                s = (g if j == fp else f) + v
                if s < ff:
                    gg = ff
                    ff = s
                    ffp = j
                elif s < gg:
                    gg = s
            f, g, fp = ff, gg, ffp
        return f

作者：ylb
链接：https://leetcode.cn/problems/minimum-falling-path-sum-ii/solutions/2381174/python3javacgotypescript-yi-ti-yi-jie-do-sko0/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```
* 时间复杂度分析:**O(n^2^)**
* 空间复杂度分析:**O(1)**