# [笔记目录](目录.md)
# 算法部分

## 滑动窗口
&emsp; 当需要保持一个经常发生变动的数组/子串时，并对所给数据中的部分按要求进行截取时可以采用滑动窗口的形式
___
### 例题
#### [76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)

困难

给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。

 

注意：
* 对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。
  
* 如果 s 中存在这样的子串，我们保证它是唯一的答案。
 

>示例 1：
>输入：s = "ADOBECODEBANC", t = "ABC"
>输出："BANC"
>解释：最小覆盖子串 "BANC" 包含来自字符串 t 的 'A'、'B' 和 'C'。


>示例 2：
>输入：s = "a", t = "a"
>输出："a"
>解释：整个字符串 s 是最小覆盖子串。

>示例 3:
>输入: s = "a", t = "aa"
>输出: ""
>解释: t 中两个字符 'a' 均应包含在 s 的子串中，
>因此没有符合条件的子字符串，返回空字符串。
 

提示：

* m == s.length
* n == t.length
* 1 <= m, n <= 105
* s 和 t 由英文字母组成
 

进阶：你能设计一个在 o(m+n) 时间内解决此问题的算法吗？

##### 本人解法：
######   首次提交
```python
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        a = {}
        b = {}

        for i in t :
            b[i] = b.get(i,0) +1 

        def Count(a,b):
            for i in b :
                if a.get(i,0) < b[i]:
                    return True
            return False
            
        n = len(s)
        l,r = 0,0 
        ans = ""
        temp = inf
        while r < n :
            while r < n and Count(a,b):
                a[s[r]] = a.get(s[r],0) +1 
                r+=1 
            while l<r and a.get(s[l],0) > b.get(s[l],-1):
                a[s[l]] =a.get(s[l],0) -1 
                l+=1 
            if r-l < temp and not Count(a,b) :
                temp = r-l 
                ans = s[l:r]
            if r >=n :
                break
            a[s[l]] =a.get(s[l],0) -1 
            l+=1 
        return ans
```
###### 想法
分析题目，要求取字符串中的子串，可以很快的想到要使用滑动窗口。虽然很丑陋，但是还是勉强满足了要求
![Alt text](data/算法/76_1.png)
###### 他人更优解
```
def minWindow(self, s: str, t: str) -> str:
    need=collections.defaultdict(int)
    for c in t:
        need[c]+=1
    needCnt=len(t)
    i=0
    res=(0,float('inf'))
    for j,c in enumerate(s):
        if need[c]>0:
            needCnt-=1
        need[c]-=1
        if needCnt==0:       #步骤一：滑动窗口包含了所有T元素
            while True:      #步骤二：增加i，排除多余元素
                c=s[i] 
                if need[c]==0:
                    break
                need[c]+=1
                i+=1
            if j-i<res[1]-res[0]:   #记录结果
                res=(i,j)
            need[s[i]]+=1  #步骤三：i增加一个位置，寻找新的满足条件滑动窗口
            needCnt+=1
            i+=1
    return '' if res[1]>len(s) else s[res[0]:res[1]+1]    #如果res始终没被更新过，代表无满足条件的结果

作者：Mcdull
链接：https://leetcode.cn/problems/minimum-window-substring/solutions/258513/tong-su-qie-xiang-xi-de-miao-shu-hua-dong-chuang-k/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

## 链表
____
## 图
&emsp;&emsp;当发现题目中构成了相连的多个节点时，即可认为是图这一方向的题目。主要的算法有**深度优先算法**，**广度优先算法**，**剪枝**等
### 例题

#### 1466. 重新规划路线

中等

n 座城市，从 0 到 n-1 编号，其间共有 n-1 条路线。因此，要想在两座不同城市之间旅行只有唯一一条路线可供选择（路线网形成一颗树）。去年，交通运输部决定重新规划路线，以改变交通拥堵的状况。

路线用 `connections` 表示，其中 `connections[i] = [a, b]` 表示从城市 a 到 b 的一条有向路线。

今年，城市 0 将会举办一场大型比赛，很多游客都想前往城市 0 。

请你帮助重新规划路线方向，使每个城市都可以访问城市 0 。返回需要变更方向的最小路线数。

题目数据保证每个城市在重新规划路线方向后都能到达城市 0 。

 

    示例 1：
    输入：n = 6, connections = [[0,1],[1,3],[2,3],[4,0],[4,5]]
    输出：3
    解释：更改以红色显示的路线的方向，使每个城市都可以到达城市 0 。
>
    示例 2：
    输入：n = 5, connections = [[1,0],[1,2],[3,2],[3,4]]
    输出：2
    解释：更改以红色显示的路线的方向，使每个城市都可以到达城市 0 。

>

    示例 3：
    输入：n = 3, connections = [[1,0],[2,0]]
    输出：0
 

提示：

* 2 <= n <= 5 * 10^4^
* `connections.length` == n-1
* `connections[i].length` == 2
* 0 <= `connections[i][0], connections[i][1]` <= n-1
* `connections[i][0]` != `connections[i][1]`

#### 本人解法
```python
class Solution:
    def minReorder(self, n: int, connections: List[List[int]]) -> int:
        inputs  = {}
        outputs  = {}
        ans = 0 
        for i,j in connections:
            if i not in outputs :
                outputs[i] = [j]
            else:
                outputs[i].append(j)
            if j not in inputs :
                inputs[j] = [i]
            else:
                inputs[j].append(i)
            
        def find(node,pre):
            temp = 0 
            for next in outputs.get(node,[]):
                if next != pre:
                    temp += 1+find(next,node)
            for next in inputs.get(node,[]):
                if next != pre :
                    temp += find(next,node)
            return temp

        if 0 in outputs :
            for i in outputs[0]:
                ans +=1
                if 0 in inputs :
                    inputs[0].append(i)
                else:
                    inputs[0] = [i]

        for i in inputs[0]:
            ans += find(i,0)
        return ans 
        

```
##### 思路
&emsp;&emsp;由题目中的铁路与各个城市相连，可以很清晰的得出本题使用的是图。由于所有的城市均要前往0城市，所以要以0城市为中心进行构图。
1. 由于路线总数有且仅有n-1条，所以不可能存在离开0城市的路线
2. 所有路线均要向着0城市方向移动
3. 所有远离0城市方向的路线均需要被改造

&emsp;&emsp;由以上三个规则可以得出需要构建两张图，一张用于存储入点的路线，一张用于获取出点的路线
&emsp;&emsp;在图构建完成后，从0城市开始向外进行搜索。
1. 先将从0城市远离的路线进行改造，以使得我们的搜索能够起步。
2. 先遍历出点图，若该点存在上一点之外的出点时，那么该出点的路线便是需要改造的。
3. 后遍历入点图，将搜索范围进行放大(同时要防止回到上一点)
____

## 堆
&emsp;&emsp; 当需要保持一个经常发生变动的列表的有序性时可以采用堆的形式
________________________________________________

### python中的使用
&emsp;&emsp; python中内置了`heapq`来方便我们构建根堆(默认只有小根堆)
#### 常用函数
> * `heappush` # 往堆中添加新值
> * `heapify` #以线性时间将一个列表转化为小根堆
> * `heappop` # 从堆中弹出并返回最小的值
_____________________________________________
### 例题
#### [23. 合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/description/)
困难
&emsp;给你一个链表数组，每个链表都已经按升序排列。

&emsp;请你将所有链表合并到一个升序链表中，返回合并后的链表。

 

    示例 1：

    输入：lists = [[1,4,5],[1,3,4],[2,6]]
    输出：[1,1,2,3,4,4,5,6]
    解释：链表数组如下：
    [
    1->4->5,
    1->3->4,
    2->6
    ]
    将它们合并到一个有序链表中得到。
    1->1->2->3->4->4->5->6

>
    示例 2：

    输入：lists = []
    输出：[]

>
    示例 3：

    输入：lists = [[]]
    输出：[]
    

提示：

* k == lists.length
* 0 <= k <= 10^4
* 0 <= lists[i].length <= 500
* -10^4 <= lists[i][j] <= 10^4
* lists[i] 按 升序 排列
* lists[i].length 的总和不超过 10^4

题解:
```python
class Solution:
    def mergeKLists(self, lists: List[ListNode]) -> ListNode:
        import heapq
        que = []
        for index, node in enumerate(lists):
                if node!=None:
                    heapq.heappush(que ,(node.val, index))
    
        dummy_node = ListNode(-1)
        cur = dummy_node
        while que:
            val, index =  heapq.heappop(que)
            cur.next = lists[index]
            cur = cur.next
            lists[index] = lists[index].next
            if lists[index] != None:
                heapq.heappush(que, (lists[index].val, index))
        return dummy_node.next

```
_____________________________________________
## 动态规划


### 例题

#### [ 1289. 下降路径最小和 II](https://leetcode.cn/problems/minimum-falling-path-sum-ii/description/)
提示 困难
给你一个 n x n 整数矩阵 grid ，请你返回 非零偏移下降路径 数字和的最小值。

非零偏移下降路径 定义为：从 grid 数组中的每一行选择一个数字，且按顺序选出来的数字中，相邻数字不在原数组的同一列。

 

示例 1：

![Alt text](data/算法/1289_1.png)

输入：grid = `[[1,2,3],[4,5,6],[7,8,9]]`
输出：13
解释：
所有非零偏移下降路径包括：
[1,5,9], [1,5,7], [1,6,7], [1,6,8],
[2,4,8], [2,4,9], [2,6,7], [2,6,8],
[3,4,8], [3,4,9], [3,5,7], [3,5,9]
下降路径中数字和最小的是 [1,5,7] ，所以答案是 13 。
示例 2：

输入：grid = `[[7]]`
输出：7
 

提示：

* n == grid.length == grid[i].length
* 1 <= n <= 200
* -99 <= grid[i][j] <= 99

##### 本人解法：
######   首次提交
```python
class Solution:
    def minFallingPathSum(self, grid: List[List[int]]) -> int:
        n = len(grid)
        a = {}

        #利用递归实现动态规划
        def get(index_x,index_y):
            temp = inf
            if (index_x,index_y) in a :
                return a[(index_x,index_y)]
            else:
                if index_x+1 < n :
                    for index , i in enumerate(grid[index_x]):
                        #不在同列时,搜索最佳答案并保留结果
                        if index != index_y:
                            temp = min(temp,get(index_x+1,index)+grid[index_x][index_y])
                    a[(index_x,index_y)] = temp
                    return temp
                else:
                    a[(index_x,index_y)] = grid[index_x][index_y]
                    return a[(index_x,index_y)]
        
        return min( get(0,i) for i in range(n))
```
###### 想法
分析题目可得，下降路径中每一行都是独立的，有且只有上一行的同列不可取。可以使用递归的方式实现动态规划，并使用字典来防止重复计算。
* 时间复杂度分析:**O(n^2^)**
* 空间复杂度分析:**O(n^2^)**
原本以为200^2^还是能接受的，可是还是出现的超时

###### 分析
每一行实际上都只用到了最小和次小值(当无法取得最小值时取次大值)，可将空间复杂度压缩为**O(n)**，同时大大缩短了查找的时间

###### 第二次提交
```python
class Solution:
    def minFallingPathSum(self, grid: List[List[int]]) -> int:
        n = len(grid)
        a = {}
        if n ==1 : #由于n==1 时无法取得次大值，故需要特殊判断
            return grid[0][0]

        def get(index_x,index_y):
            temp = [inf,-1] #最大值
            temp_1 = [inf,-1]#次大值
            if index_x in a :
                return a[index_x][1] if index_y != a[index_x][0] else a[index_x][2] 
            else:
                if index_x+1 < n :
                    for index in range(n):
                        temp_2 = get(index_x+1,index)+grid[index_x][index]
                        if temp_2 < temp[0] :
                            temp_1 = temp
                            temp = (temp_2,index)
                        elif temp_2 < temp_1[0]:
                            temp_1 = (temp_2,index)
                    a[index_x] = (temp[1],temp[0],temp_1[0])
                else:
                    for index in range(n):
                        temp_2 = grid[n-1][index]
                        if temp_2 < temp[0] :
                            temp_1 = temp
                            temp = (temp_2,index)
                        elif temp_2 < temp_1[0]:
                            temp_1 = (temp_2,index)
                    a[index_x] = (temp[1],temp[0],temp_1[0])
            return a[index_x][1] if index_y != a[index_x][0] else a[index_x][2]
        return min( get(0,i) for i in range(n))
```
* 时间复杂度分析:**O(n^2^)**
* 空间复杂度分析:**O(n)**
成功通过
![Alt text](data/算法/1289_2.png)

###### 他人更优解
``` python
class Solution:
    def minFallingPathSum(self, grid: List[List[int]]) -> int:
        f = g = 0
        fp = -1
        for row in grid:
            ff = gg = inf
            ffp = -1
            for j, v in enumerate(row):
                s = (g if j == fp else f) + v
                if s < ff:
                    gg = ff
                    ff = s
                    ffp = j
                elif s < gg:
                    gg = s
            f, g, fp = ff, gg, ffp
        return f

作者：ylb
链接：https://leetcode.cn/problems/minimum-falling-path-sum-ii/solutions/2381174/python3javacgotypescript-yi-ti-yi-jie-do-sko0/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```
* 时间复杂度分析:**O(n^2^)**
* 空间复杂度分析:**O(1)**